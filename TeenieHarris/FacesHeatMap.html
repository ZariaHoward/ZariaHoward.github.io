<!DOCTYPE html>
<meta charset="utf-8">
<html>
  <head>
    <style>
      rect.bordered {
        stroke: #E6E6E6;
        stroke-width:2px;   
      }

      text.mono {
        font-size: 7pt;
        font-family: Consolas, courier;
        fill: #aaa;
      }

      text.axis-xVal {
        fill: #000;
      }

      text.axis-yVal {
        fill: #000;
      }
    </style>
    <script src="http://d3js.org/d3.v3.js"></script>
  </head>
  <body>
    <input type="button" onclick="location.href='https://zariahoward.github.io/index.html';" value="Go Back to Homepage" /><br>
    <br>
    <p>
      This page is a visualization of the spatial locations of faces in the Teenie Harris archive. To get an idea of Teenie Harris' compositions, we need to get and idea of the positions of the people in the photos. The majority of his photos have a 4:5 ratio, which means I only had to plot 2 arrangements: the vertical case and the horizontal case. Since all of the photos were resized to have a max side-length of 1600, I just plotted where the faces would land on a 1600x1600 pixel grid assuming the photos were placed closest to the upper left hand corner. 
        <strong>
        Each box represents a 40x40 pixel grid and the color is representative of how many faces overlap with that 40 x 40 pixel grid.
        </strong> 
        I used R to create a matrix of where the faces were, exported it as a tsv and then imported it into javascript. Although I think the visualization is effective, one thing I don't like is how the gradient of colors don't really reflect the gradient of values. It makes some rings look like they contain more faces than what are actually located there. However the legend is at the bottom of the page.    
        <strong>
          <br>
        The First Button is for Horizontal Pictures
        </strong>
        <br>
        <strong>
        The Second Button is for Vertical Pictures
        </strong>
      </p>

    Results:
    <ul>
      <li>Only 13% of his photos don't have faces</li>
      <li>Oftentimes, even faces with confidences as low as 0.3 still were actually faces, I could not find any false positives</li>
      <li>The confidence is normally distributed. The distribution has a mean of 0.98 with a standrd deviation of 0.22</li>
      <li>The face sizes retrieved from the library are fixed and discrete. This is a result of the library </li>
      <li>The ratio of small faces to large faces is very small, which is an effect of the fact that the majority of his photos are group shots and public events</li>
      <li>Faces take up approximately 1.09% of the pixels in the whole collection.</li>
      <li>Faces that are bigger in the photo almost always have a high confidence associated with them. Faces that are smaller have a confidences anywhere from 0 to 1.2, the variance is greater in small faces. </li>
    </ul>
    <p> The plots used to get these results were created in R you can view them below: </p>
    <div id="dataset-picker">
    </div>
    <div id="chart"></div>
    
    <script type="text/javascript">
      var margin = { top: 30, right: 0, bottom: 100, left: 40 },
          width = 950 - margin.left - margin.right,
          height = 1000 - margin.top - margin.bottom,
          gridSize = Math.floor(width / 40),
          legendElementWidth = gridSize*2,
          buckets = 9,
          colors = ["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58"], // alternatively colorbrewer.YlGnBu[9]
          step = 0,
          xVals = [],
          yVals = [];
          for (step = 1; step <= 40; step++){
            xVals.push((step*40).toString());
            yVals.push((step*40).toString());
          }
          // xVals = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12","13","14",
          // "15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40"],
          // yVals = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12","13","14",
          // "15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40"],
          datasets = ["D3VerticalData.tsv", "D3HorizontalData.tsv"];

      var svg = d3.select("#chart").append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var xValLabels = svg.selectAll(".xValLabel")
          .data(xVals)
          .enter().append("text")
            .text(function (d) { return d; })
            .attr("x", 0)
            .attr("y", function (d, i) { return i * gridSize; })
            .style("text-anchor", "end")
            .attr("transform", "translate(-6," + gridSize / 1.5 + ")")
            .attr("class", function (d, i) { return ((i >= 0 && i <= 4) ? "dayLabel mono axis axis-xVal" : "dayLabel mono axis"); });

      var yValLabels = svg.selectAll(".yValLabel")
          .data(yVals)
          .enter().append("text")
            .text(function(d) { return d; })
            .attr("x", function(d, i) { return i * gridSize; })
            .attr("y", 0)
            .style("text-anchor", "middle")
            .attr("transform", "translate(" + gridSize / 2 + ", -6)")
            .attr("class", function(d, i) { return ((i >= 7 && i <= 16) ? "timeLabel mono axis axis-yVal" : "timeLabel mono axis"); });

      var heatmapChart = function(tsvFile) {
        d3.tsv(tsvFile,
        function(d) {
          // the things before the colon HAVE to match the labels in the csv file. the things after are naming the variables you'll use to call it for the rest of the function
          // the + turns it into a number
          return {
            yVal: +d.xVal,
            xVal: +d.yVal,
            Value: +d.Value
          };
        }, 
        function(error, data) {
          console.log("i am hereeeee...");
          var colorScale = d3.scale.quantile()
              .domain([0, buckets - 1, d3.max(data, function (d) { return d.Value; })])
              .range(colors);

          var cards = svg.selectAll(".hour")
              .data(data, function(d) {return d.xVal+':'+d.yVal;});
          console.log(cards);
          cards.append("title");
//  Everything in quotes in the attributes are html built in stuff that you are labeling
//  selectAll is not selecting anything in these cases, it's creating attributes,
// d and d3 aren't actual things. they are placeholders for the function you are definiing. the variable data is being passed in as d or d3
// 
          cards.enter().append("rect")
              .attr("x", function(d) { return (+d.xVal - 1) * gridSize; })
              .attr("y", function(d) { return (+d.yVal - 1) * gridSize; })
              .attr("rx", 4)
              .attr("ry", 4)
              .attr("class", "xVal bordered")
              .attr("width", gridSize)
              .attr("height", gridSize)
              .style("fill", colors[0]);
          console.log(cards);

          cards.transition().duration(1000)
              .style("fill", function(d) { return colorScale(d.Value); });

          cards.select("title").text(function(d) { return d.Value; });
          
          cards.exit().remove();

          var legend = svg.selectAll(".legend")
              .data([0].concat(colorScale.quantiles()), function(d) { return d; });

          legend.enter().append("g")
              .attr("class", "legend");

          legend.append("rect")
            .attr("x", function(d, i) { return legendElementWidth * i; })
            .attr("y", height + 15)
            .attr("width", legendElementWidth)
            .attr("height", gridSize / 2)
            .style("fill", function(d, i) { return colors[i]; });

          legend.append("text")
            .attr("class", "mono")
            .text(function(d) { return "â‰¥ " + Math.round(d); })
            .attr("x", function(d, i) { return legendElementWidth * i; })
            .attr("y", height + gridSize + 15);

          legend.exit().remove();

        });  
      };

      heatmapChart("D3VerticalData.tsv");
      
      var datasetpicker = d3.select("#dataset-picker").selectAll(".dataset-button")
        .data(datasets);

      datasetpicker.enter()
        .append("input")
        .attr("value", function(d){ return "Dataset " + d })
        .attr("type", "button")
        .attr("class", "dataset-button")
        .on("click", function(d) {
          heatmapChart(d);

        });
    </script>
  </body>
</html>